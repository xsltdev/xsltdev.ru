---
layout: default
title: Погружение
nav_order: 5
grand_parent: Справочник Typescript
parent: Декларации Typescript
---

<!-- prettier-ignore-start -->
# Теоретические основы файлов определений: глубокое погружение
{: .no_toc }
<!-- prettier-ignore-end -->

Описать модуль так, чтобы он имел в точности необходимый API, может оказаться сложной задачей.
К примеру, может понадобиться модуль, который вызывается с `new` или без, создавая при этом разные типы, имеет различные именованные типы, упорядоченные иерархически, и несколько свойств на самом объекте модуля.

<!-- prettier-ignore -->
1. TOC
{:toc}

Прочитав это руководство, вы получите инструменты для написания сложных файлов определений, предоставляющих удобный API.
Это руководство уделяет основное внимание модульным (или UMD) библиотекам из-за множества их вариантов и разнообразия.

## Ключевые принципы

Для того, чтобы понять, как придать определению любую форму, нужно понять ключевые принципы работы TypeScript.

### Типы

Если вы читаете это руководство, то, наверное, уже примерно представляете, что такое тип в TypeScript.
Но для большей ясности укажем, что тип вводится с помощью:

- Объявления псевдонима типа (`type sn = number | string;`)
- Объявления интерфейса (`interface I { x: number[]; }`)
- Объявления класса (`class C { }`)
- Объявления перечисления (`enum E { A, B, C }`)
- Объявления `import`, которое ссылается на тип

Каждое из таких объявлений создает новое имя типа.

### Значения

Как и с типами, вы, скорее всего, понимаете, что такое значения.
Значения — это имена, на которые можно ссылаться в выражениях во время выполнения кода.
К примеру, `let x = 5;` создает значение под именем `x`.

Опять же, для ясности, укажем, что значения создаются следующими конструкциями:

- объявлениями `let`, `const` и `var`.
- объявлениями `namespace` или `module`, внутри которых содержится значение
- объявлением `enum`
- объявлением `class`
- объявлением `import`, которое ссылается на значение
- объявлением `function`

### Пространства имен

Типы могут существовать внутри _пространств имен_.
К примеру, если взять объявление `let x: A.B.C`, то можно сказать, что тип `C` находится в пространстве имен `A.B`.

Здесь есть тонкий и важный момент — `A.B` не обязательно является типом или значением.

## Простые сочетания: одно имя, несколько значений

Взяв имя `A`, можно прийти к одному из трех вариантов того, что оно означает: тип, значение или пространство имен.
Как интерпретируется имя, зависит от контекста, в котором оно используется.
К примеру, в объявлении `let m: A.A = A;` имя `A` в первый раз используется как пространство имен, потом как имя типа, а затем как значение.
Разные варианты могут приводить к указанию на совершенно разные объявления!

Все это может показаться запутанным, но на самом деле очень удобно, если только имена не слишком перегружаются.
Посмотрим на полезные стороны такого поведения сочетаний.

### Встроенные сочетания

Проницательный читатель мог заметить, что, например, `class` появляется и в списке _типов_, и в списке _значений_.
Определение `class C { }` создает две вещи: _тип_ `C`, который ссылается на форму экземпляра класса, и _значение_ `C`, которое ссылается на функцию-конструктор для данного класса.
Определения перечислений ведут себя так же.

### Пользовательские сочетания

Допустим, мы написали файл модуля `foo.d.ts`:

```ts
export var SomeVar: { a: SomeType }
export interface SomeType {
  count: number
}
```

И затем используем его:

```ts
import * as foo from './foo'
let x: foo.SomeType = foo.SomeVar.a
console.log(x.count)
```

Это отлично работает, но мы могли бы понять, что `SomeType` и `SomeVar` тесно связаны друг с другом, и захотели бы дать им одно и то же имя.
С помощью сочетания можно представить две различных сущности (значение и тип) под одним именем `Bar`:

```ts
export var Bar: { a: Bar }
export interface Bar {
  count: number
}
```

Это дает хорошую возможность для деструктуризации в использующем модуль коде:

```ts
import { Bar } from './foo'
let x: Bar = Bar.a
console.log(x.count)
```

Здесь мы использовали `Bar` и как тип, и как значение.
Отметим, что не обязательно определять значение `Bar` как имеющее тип `Bar` — они независимы.

## Сложные сочетания

Некоторые объявления могут сочетаться между несколькими объявлениями.
Например, `class C { }` и `interface C { }` могут сосуществовать, и оба добавлять свойства к типам `C`.

Это допустимо, пока не создает конфликтов.
Правило таково, что значения всегда конфликтуют с другими значениями с тем же именем, если только они не объявлены как `namespace`; типы конфликтуют, если объявлены с помощью псевдонима типа (`type s = string`), а пространства имен не конфликтуют никогда.

Посмотрим, как это можно использовать.

### Добавление с помощью `interface`

К интерфейсу можно добавить члены с помощью другого объявления `interface`:

```ts
interface Foo {
  x: number;
}
// ... где-то в другом месте ...
interface Foo {
  y: number;
}
let a: Foo = ...;
console.log(a.x + a.y); // OK
```

Это работает и с классами:

```ts
class Foo {
  x: number;
}
// ... где-то в другом месте ...
interface Foo {
  y: number;
}
let a: Foo = ...;
console.log(a.x + a.y); // OK
```

Отметим, что с помощью интерфейса нельзя добавить что-либо к псевдониму типа (`type s = string;`).

### Добавление с помощью `namespace`

Объявление `namespace` можно использовать для добавления новых типов, значений и пространств имен, если это не создает конфликтов.

К примеру, можно добавить статический член к классу:

```ts
class C {}
// ... где-то в другом месте ...
namespace C {
  export let x: number
}
let y = C.x // OK
```

В данном примере значение было добавлено к _статической_ части `C` (функции-конструктору).
Так произошло потому, что мы добавили _значение_, а контейнером для значения может служить только другое значение (типы содержатся в пространствах имен, а пространства имен — в других пространствах имен).

Тем же способом к классу можно добавить тип:

```ts
class C {}
// ... где-то в другом месте ...
namespace C {
  export interface D {}
}
let y: C.D // OK
```

В этом примере пространства имен `C` не существовало, пока мы не написали объявление `namespace` для него.
`C` в смысле пространства имен не конфликтует со значениями или типами под именем `C`, которые создаются объявлением класса.

И наконец, с помощью объявлений `namespace` можно осуществлять различные виды слияний.
Следующий пример не очень реалистичен, но показывает все разновидности интересного поведения:

```ts
namespace X {
  export interface Y {}
  export class Z {}
}

// ... где-то в другом месте ...
namespace X {
  export var Y: number
  export namespace Z {
    export class C {}
  }
}
type X = string
```

В этом примере первый блок создает следующие смыслы для имен:

- Значение `X` (поскольку объявление пространства имен содержит значение, `Z`)
- Пространство имен `X` (поскольку объявление пространства имен содержит тип, `Y`)
- Тип `Y` в пространстве имен `X`
- Тип `Z` в пространстве имен `X` (часть экземпляра класса)
- Значение `Z`, которое является свойством значения `X` (функция-конструктор класса)

Второй блок создает следующие смыслы:

- Значение `Y` (с типом `number`), которое является свойством значения `X`
- Пространство имен `Z`
- Значение `Z`, которое является свойством значения `X`
- Тип `C` внутри пространства имен `X.Z`
- Значение `C`, которое является свойством значения `X.Z`
- Тип `X`

## Использование с `export =` или `import`

Важно, что объявления `export` и `import` экспортируют или импортируют _все смыслы_ того, на что ссылаются.

## Ссылки

- [Погружение](http://typescript-lang.ru/docs/declaration%20files/Deep%20Dive.html)
