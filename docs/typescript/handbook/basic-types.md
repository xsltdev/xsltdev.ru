# Базовые типы

## Введение

Typescript является языком со статической типизацией. Тип не может быть изменен в ходе выполнения программы. Это позволяет снизить большое количество ошибок и выявить многие из них еще на этапе компиляции.

В Typescript есть несколько простых типов данных: numbers (числа), strings (строки), structures (структуры), boolean (логический). Он поддерживает все типы, которые есть в Javascript, дополняя удобным типом перечислений (enum).

## Boolean

Наиболее базовым типом является логический true/false, который в Javascript и Typescript называется boolean.

```ts
let isDone: boolean = false
```

## Number

Как и в Javascript, тип numbers в Typescript являются числом с плавающей точкой. Кроме десятичного и шестнадцатиричного формата, поддерживаются бинарный и восьмеричный, введенные в ECMAScript 2015.

```ts
let decimal: number = 6
let hex: number = 0xf00d
let binary: number = 0b1010
let octal: number = 0o744
```

## String

Еще одна важная часть программ в веб-страницах и серверах это текстовые данные. Как и в других языках, в Typescript используется то же обозначение "string" для таких данных. Как и Javascript, в Typescript используются двойные (`"`) или одинарные (`'`) кавычки для обрамления текстовых данных.

```ts
let name: string = 'bob'
name = 'smith'
```

Вы также можете использовать _строки с шаблонами_, которые могут быть многострочными и иметь встроенные выражения. Эти строки окружаются обратными апострофами или кавычками(`` ` ``) и встроенные выражения обозначаются как `${ expr }`.

```ts
let name: string = `Gene`
let age: number = 37
let sentence: string = `Hello, my name is ${name}.

I'll be ${age + 1} years old next month.`
```

Эквивалент этого объявления `sentence`:

```ts
let sentence: string = 'Hello, my name is ' + name + '.\n\n' + "I'll be " + (age + 1) + ' years old next month.'
```

## Array

TypeScript, как и JavaScript, имеет массивы значений.
Тип массива может быть определен одним из двух способов.
Первый - обозначать тип элементов массива перед `[]`:

```ts
let list: number[] = [1, 2, 3]
```

Второй способ - использовать обобщение `Array<elemType>`:

```ts
let list: Array<number> = [1, 2, 3]
```

## Tuple

Тип Tuple дает вам возможность объявить массив с известным фиксированным количеством элементов, которые не обязаны быть одного типа. Например, вы хотите иметь значение Tuple как пару "строка" и "число":

```ts
// Объявление типа tuple
let x: [string, number]
// Его инициализация
x = ['hello', 10] // OK
// Некорректная инициализация вызовет ошибку
x = [10, 'hello'] // Error
```

Когда вы получаете элемент с известным идексом, будет возвращен тип этого элемента:

```ts
console.log(x[0].substr(1)) // OK
console.log(x[1].substr(1)) // Error, 'number' does not have 'substr'
```

При получении элемента с идексом вне известного диапазона, будет возвращен тип Union:

```ts
x[3] = 'world' // OK, тип string может быть присвоен (string | number)

console.log(x[5].toString()) // OK, 'string' и 'number' оба имеют метод toString

x[6] = true // Ошибка, boolean это не (string | number)
```

Тип Union будет описан чуть позже, в разделе продвинутых типов.

## Enum (Перечисления)

Полезным дополнением к стандартному набору типов из Javascript является тип Enum.
Как и в языках подобных C#, тип enum - это более удобный способ задания понятных имен набору численных значений.

```ts
enum Color {
  Red,
  Green,
  Blue
}
let c: Color = Color.Green
```

По умолчанию перечисления (Enum) начинаются с `0`.
Вы можете изменить это путем прямого указания значения для одного из членов перечисления.
Например, мы можем начать предыдущий пример с `1` вместо `0`:

```ts
enum Color {
  Red = 1,
  Green,
  Blue
}
let c: Color = Color.Green
```

Или даже задать значения для всех членов:

```ts
enum Color {
  Red = 1,
  Green = 2,
  Blue = 4
}
let c: Color = Color.Green
```

Удобная особенность перечислений состоит в том, что вы также можете получить имя члена перечисления, передав его числовое значение.
Например, если у нас есть значение `2` и мы хотим посмотреть, чему оно соответствует в перечислении `Color` описанном выше, мы можем сделать это так:

```ts
enum Color {
  Red = 1,
  Green,
  Blue
}
let colorName: string = Color[2]

alert(colorName)
```

## Any

Нам может потребоваться описать тип переменных, который мы не знаем, когда пишем наше приложение.
Эти значения могут быть получены из динамического контента, например от пользователя или от сторонней библиотеки.
В этих случаях мы хотим отключить проверку типов и позволить значениям пройти проверку на этапе компиляции.
Чтобы это сделать, нужно использовать тип `any`:

```ts
let notSure: any = 4
notSure = 'maybe a string instead'
notSure = false // ok, это определенно boolean
```

Тип `any` - это мощный способ работы с существующим Javascript, который позволяет вам постепенно включать все больше проверок типов на этапе компиляции.
Вы можете ожидать, что `Object` будет играть такую же роль, какую и в других языках. Но переменные типа `Object` позволяют вам только присваивать им любое значение. Вы не можете вызывать у них необъявленные методы, даже те, которые могут существовать на этапе исполнения программы:

```ts
let notSure: any = 4
notSure.ifItExists() // ifItExists может существовать на этапе исполнения
notSure.toFixed() // метод toFixed существует (но компилятор не проверяет это)

let prettySure: Object = 4
prettySure.toFixed() // Ошибка: Свойство 'toFixed' не существует у типа 'Object'.
```

Тип `any` может быть также полезен, если вы знаете некоторую часть типа переменной, но не весь.
Например, у вас может быть массив с элементами различных типов:

```ts
let list: any[] = [1, true, 'free']

list[1] = 100
```

## Void

`void` это нечто противоположное `any`: отсутствие каких-либо типов. Чаще всего он используется в качестве возвращаемого типа функций, которые не возвращают никакого значения.

```ts
function warnUser(): void {
  alert('This is my warning message')
}
```

Объявление переменных с типом `void` бесполезно, потому что вы можете присвоить им только значения `undefined` или `null`:

```ts
let unusable: void = undefined
```

## Type assertions (Приведение к типу)

Иногда вы попадаете в ситуацию, когда знаете больше о значении переменной, чем Typescript.
Обычно это случается, когда вы знаете, что тип некоторой сущности может быть более специфичным, чем ее текущий.

_Type assertions_ - это способ сказать компилятору "поверь мне, я знаю, что делаю".
Type assertion это как приведение к типу в других языках, но оно не делает никаких специальных проверок или реструктуризаций данных.
Приведение к типу не имеет никакого воздействия на этапе выполнения программы и используется только компилятором.
Typescript предполагает, что программист сделает все необходимые проверки, которые потребуются.

Приведение к типу может быть сделано двумя способами.
Первый это использование синтаксиса угловых скобок:

```ts
let someValue: any = 'this is a string'

let strLength: number = (<string>someValue).length
```

И другой - использование ключевого слова `as`:

```ts
let someValue: any = 'this is a string'

let strLength: number = (someValue as string).length
```

Эти два примера эквивалентны. Использование одного из них это просто выбор более предпочтительного варианта; тем не менее, когда вы используете Typescript с JSX, возможно только приведение к типу через `as`.

## Немного о `let`

Вы могли заметить, что недавно было введено новое ключевое слово `let` вместо `var` из JavaScript, с которым вы знакомы.
Ключевое слово `let` - это просто новый способ задания переменной в JavaScript, который уже доступен в Typescript.
Мы обсудим детали позже, сейчас же просто знайте, что много проблем в Javascript можно избежать, используя `let`. Поэтому вы должны использовать его вместо `var`, где это возможно.

## Ссылки

- [Базовые типы](http://typescript-lang.ru/docs/Basic%20Types.html)
