---
layout: default
title: Пространства имен и модули
nav_order: 15
parent: Справочник Typescript
---

<!-- prettier-ignore-start -->
# Пространства имен и модули
{: .no_toc }
<!-- prettier-ignore-end -->

<!-- prettier-ignore -->
1. TOC
{:toc}

> **Замечание по поводу терминологии:**
> Важно отметить, что в TypeScript 1.5 изменилась номенклатура.
> "Внутренние модули" теперь называются "пространства имён".
> "Внешние модули" стали просто "модулями". Это было сделано, чтобы согласовать терминологию с [ECMAScript 2015](http://www.ecma-international.org/ecma-262/6.0/), (а именно: `module X {` эквивалентен предпочитаемому в настоящее время `namespace X {`).

## Введение

Данный раздел документации описывает различные пути организации вашего кода в TypeScript с помощью пространств имён и модулей.
Мы также затронем несколько сложных вопросов и отметим основные подводные камни, которые могут встретиться при использовании пространств имен и модулей в Typescript.

См. [модули](./Modules.html) для получения более подробной информации о модулях.
См. [пространства имен](./Namespaces.html) для получения более подробной информации о пространствах имен.

## Использование пространств имен

Пространства имен — это просто именованные объекты JavaScript, расположенные в глобальном пространстве имен. И это делает их очень простыми в использовании.
Пространства имен могут располагаться в нескольких файлах и могут быть объединены с помощью ключа `--outFile`.
Они удобны для структурирования кода в веб-приложении, когда все зависимости находятся в тегах `<script>` вашей HTML-станицы.

Так же как и в случае замусоривания глобального пространства имён, может оказаться трудно определить зависимости компонентов, особенно в больших приложениях.

## Использование модулей

Аналогично пространствам имен, модули могут содержать и код, и объявления. Основное отличие состоит в том, что модули _объявляют_ свои зависимости.

Модули также зависят от загрузчиков (например CommonJs/Require.js).
Для небольшого JS-приложения такой подход может оказаться неоптимальным, но для более крупных решений усилия окупаются модульностью и удобством поддержки.
Модули также удобнее с точки зрения повторного использования кода, более сильной изоляции и лучшей поддержки в инструментах создания пакетов.

Также стоит отметить, что для приложений Node.js модули являются основным и рекомендуемым способом структурирования кода.

Начиная с ECMAScript 2015, модули являются неотъемлемой частью языка и должны поддерживаться всеми совместимыми реализациями JavaScript-движков.
Таким образом, для новых проектов модули должны быть рекомендуемым способом организации кода.

## Ошибки при работе с пространствами имен и модулями

В этой части описаны основные ловушки, в которые можно попасть при работе с модулями и пространствами имен, а также способы их обхода.

### Ссылка (`/// <reference>`) на модуль

Часто встречается ошибка, при которой для того, чтобы сослаться на файл модуля, вместо оператора `import` используется конструкция `/// <reference ... />`.
Чтобы разобраться, в чем разница, необходимо сначала понять, как на основе пути, заданного в операторе `import` (например: `...` в `import x from "...";`, `import x = require("...");`, и т.д.) компилятор находит для модуля информацию о типах.

Компилятор попытается найти `.ts`, `.tsx`, и затем `.d.ts`, используя указанный путь.
Если определённый файл не может быть найден, компилятор начнёт искать _объявления внешних модулей_ (ambient module declaration).
Напомним, что такие модули должны быть объявлены в файле `.d.ts`.

- `myModules.d.ts`

  ```ts
  // В файле .d.ts или в файле .ts, который не является модулем:
  declare module 'SomeModule' {
    export function fn(): string
  }
  ```

- `myOtherModule.ts`

  ```ts
  /// <reference path="myModules.d.ts" />
  import * as m from 'SomeModule'
  ```

Здесь ссылочный тег позволяет найти файл, содержащий объявления внешних модулей.
Таким образом подключается файл `node.d.ts`, используемый в нескольких примерах использования TypeScript.

### Использование пространств имен без необходимости

Если вы переводите программу с пространств имен на модули, в итоге легко прийти к файлу следующего вида:

- `shapes.ts`

  ```ts
  export namespace Shapes {
    export class Triangle {
      /* ... */
    }
    export class Square {
      /* ... */
    }
  }
  ```

В том, что модуль верхнего уровня `Shapes` "оборачивает" `Triangle` и `Square`, нет никакого смысла.
Это сбивает с толку и раздражает пользователей вашего модуля:

- `shapeConsumer.ts`

  ```ts
  import * as shapes from './shapes'
  let t = new shapes.Shapes.Triangle() // shapes.Shapes?
  ```

Ключевой особенностью модулей в TypeScript является то, что в одной области видимости модули никогда не сливаются друг с другом.
Поскольку пользователь модуля решает, какое имя ему назначить, нет необходимости заранее заключать экспортируемые элементы в отдельное пространство имен.

Чтобы повторить, почему не следует пытаться заключать содержимое модуля в пространства имен, вспомним, что основной их идеей является обеспечение логической группировки кода и предотвращение конфликтов имен.
А модуль сам по себе уже обеспечивает логическую группировку, и его имя верхнего уровня определяется импортирующим кодом, поэтому нет никакой необходимости использовать дополнительный уровень вложенности для экспортируемых из модуля объектов.

Отредактированный пример:

- `shapes.ts`

  ```ts
  export class Triangle {
    /* ... */
  }
  export class Square {
    /* ... */
  }
  ```

- `shapeConsumer.ts`

  ```ts
  import * as shapes from './shapes'
  let t = new shapes.Triangle()
  ```

### Недостатки модулей

Поскольку соотношение между JS-файлами и модулями — один к одному, в TypeScript существует такое же соотношение между исходными и сгенерированными JavaScript-файлами.
Это проявляется в том числе в невозможности использовать опцию компилятора `--outFile` для соединения нескольких исходных файлов модулей в один JavaScript-файл.

## Ссылки

- [Пространства имен и модули](http://typescript-lang.ru/docs/Namespaces%20and%20Modules.html)
