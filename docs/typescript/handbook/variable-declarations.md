# Объявление переменных

`let` и `const` - относительно новые типы объявления переменных в JavaScript.
Как мы упомянули ранее, `let` похож на `var`в некотором смысле, но позволяет пользователям избежать некоторые из общих ошибок, с которыми сталкиваются в JavaScript.
`const` это расширение `let`, которое предотвращает переопределение переменных.

Так как TypeScript является надстройкой над Javascript, язык также поддерживает `let` и `const`.
Далее мы подробнее расскажем об этих новых объявлениях переменных и объясним, почему они более предпочтительны, чем `var`.

Если вы использовали JavaScript поверхностно, следующая секция секция поможет освежить некоторые важные моменты.
Если вы хорошо знакомы со всеми причудами объявления `var` в JavaScript, вы можете пропустить эту часть.

## Объявления `var`

Объявление переменной в JavaScript всегда происходит с помощью ключевого слова `var`.

```ts
var a = 10
```

Как вы наверняка поняли, мы только что объявили переменную с именем `a` и значением `10`.

Мы также можем объявить переменную внутри функции:

```ts
function f() {
  var message = 'Hello, world!'

  return message
}
```

и мы также имеем доступ к этим переменным внутри других функций:

```ts
function f() {
  var a = 10
  return function g() {
    var b = a + 1
    return b
  }
}

var g = f()
g() // возвращает 11;
```

В примере выше `g` захватывает(замыкает в себе) переменную `a`, объявленную в `f`.
В любой точке, где будет вызвана `g`, значение `a` будет связано со значением `a` в функции `f`.
Даже если `g` вызвана однажды и `f` закончила выполнение, можно получить доступ и модифицировать `a`.

```ts
function f() {
  var a = 1

  a = 2
  var b = g()
  a = 3

  return b

  function g() {
    return a
  }
}

f() // возвращает 2
```

### Правила области видимости (Scoping)

Объявление `var` имеет несколько странных правил области видимости для тех, кто использует другие языки программирования.
Посмотрите не следующий пример:

```ts
function f(shouldInitialize: boolean) {
  if (shouldInitialize) {
    var x = 10
  }

  return x
}

f(true) // returns '10'
f(false) // returns 'undefined'
```

Некоторые могут повторно посмотреть на тот пример.
Переменная `x` была объявлена _внутри блока `if`_, и мы можем получить к ней доступ вне этого блока.
Это потому что объявления `var` доступны где бы то ни было внутри содержащей их функции, модуля, пространства имен(namespace) или же глобальной области видимости несмотря на блок, в котором они содержатся.
Некоторые называют это _`var`-видимость_ or _function-видимость_.
Параметры также видны внутри функции.

Эти правила области видимости могут вызвать несколько типов ошибок.
Одна из раздражающих проблем - это то, что не является ошибкой объявление переменной несколько раз:

```ts
function sumMatrix(matrix: number[][]) {
  var sum = 0
  for (var i = 0; i < matrix.length; i++) {
    var currentRow = matrix[i]
    for (var i = 0; i < currentRow.length; i++) {
      sum += currentRow[i]
    }
  }

  return sum
}
```

Скорее всего несложно заметить, что внутренний цикл `for` случайно перезапишет переменную `i`, потому что `i` имеет области видимости внутри функции sumMatrix.
Опытные разработчики знают, что похожие ошибки проскальзывают при code review и могут быть причиной бесконечной фрустрации.

### Variable capturing quirks

Попробуйте быстро догадаться, какой будет вывод у этого кода:

```ts
for (var i = 0; i < 10; i++) {
  setTimeout(function() {
    console.log(i)
  }, 100 * i)
}
```

Для тех, кто незнаком, `setTimeout` пытается выполнить функцию после указанного количества миллисекунд (при это ожидая, пока какой-либо другой код прекратит выполняться)

Готовы? Вот результат::

```text
10
10
10
10
10
10
10
10
10
10
```

Многие JavaScript разработчики знакомы с таким поведением, но если вы удивлены, вы определенно не одиноки.
Большинство ожидает, что вывод будет таким:

```text
0
1
2
3
4
5
6
7
8
9
```

Помните, что мы упомянули ранее о замыкании переменных?

> В любой точке, где будет вызвана `g`, значение `a` будет связано со значением `a` в функции `f`.

Давайте рассмотрим это в контексте нашего примера.
`setTimeout` запустит функцию через несколько миллисекунд, после завершения цикла `for`.
К моменту, когда цикл `for` закончит выполнение, `i` будет равняться `10`.
Поэтому каждый раз, когда отложенная функция будет вызвана, она возвратит `10`!

Самый простой способ решить проблему - использовать немедленный запуск анонимной функции, чтобы захватить `i` на каждой итерации:

```ts
for (var i = 0; i < 10; i++) {
  // capture the current state of 'i'
  // by invoking a function with its current value
  ;(function(i) {
    setTimeout(function() {
      console.log(i)
    }, 100 * i)
  })(i)
}
```

Этот странно выглядящий шаблон на самом деле не редок.

## Объявления `let`

Сейчас мы уже понимаем, что `var` имеет некоторые проблемы, именно поэтому появился новый способ объявления переменных `let`. Они записываются точно также, как и объявления `var`.

```ts
let hello = 'Hello!'
```

Ключевое различие не в синтаксисе, а в семантике, в которую мы сейчас погрузимся.

### Блочная область видимости

Когда переменная объявляется с использованием `let`, она используется в режиме _блочной области видимости_.
В отличие от переменных, объявленных с помощью `var`, чьи области видимости распространяются на всю функцию, в которой они находятся, переменные блочной области видимости не видимы вне их ближайшего блока или же цикла `for`.

```ts
function f(input: boolean) {
  let a = 100

  if (input) {
    // Здесь мы видим переменную 'a'
    let b = a + 1
    return b
  }

  // Ошибка: 'b' не существует в этом блоке
  return b
}
```

Здесь мы имеем две локальные переменные `a` и `b`.
Область видимости `a` ограничена телом функции `f`, в то время как область `b` ограничена блоком условия `if`.

Переменные, объявленные в блоке `catch` имеют те же правила видимости.

```ts
try {
  throw 'oh no!'
} catch (e) {
  console.log('Oh well.')
}

// Error: 'e' doesn't exist here
console.log(e)
```

Другое свойство переменных блочной области видимости - к ним нельзя обратиться перед тем, как они были объявлены.
При том, что переменные блочной области видимости представлены везде в своем блоке, в каждой точке до их объявления находится _мертвая зона_. Это просто такой способ сказать, что вы не можете получить к ним доступ до утверждения `let` и, к счастью, TypeScript напомнит вам об этом.

```ts
a++ // неверно использовать 'a' до ее объявления;
let a
```

Однако, вы все еще можете _захватить_ (замкнуть) переменную с блочной областью видимости до ее объявления.
Правда, попытка вызвать такую функцию до ее объявления приведет к ошибке.
Если вы компилируете в стандарт ES2015, это вызовет ошибку; тем не менее, прямо сейчас TypeScript разрешает это и не будет указывать на ошибку.

```ts
function foo() {
  // okay to capture 'a'
  return a
}

// illegal call 'foo' before 'a' is declared
// runtimes should throw an error here
foo()

let a
```

Для более подробной информации о мертвых зонах перейдите по этой ссылке: [Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let).

### Повторное объявление и экранирование

В случае объявлений `var` не имеет значения, как много раз вы объявляете одну и ту же переменную. Вы всегда получите одну.

```ts
function f(x) {
  var x
  var x

  if (true) {
    var x
  }
}
```

В примере выше все объявления `x` на самом деле указывают на _одну и ту же_ `x`, и это вполне допустимо.
Это часто является источником багов. Поэтому хорошо, что объявления `let` этого не позволяют.

```ts
let x = 10
let x = 20 // Ошибка: нельзя переопределить 'x' в одной области видимости
```

Переменные не обязательно должны обе быть с блочной областью видимости в TypeScript, чтобы компилятором была указана ошибка.

```ts
function f(x) {
  let x = 100 // ошибка: пересекается с параметром функции
}

function g() {
  let x = 100
  var x = 100 // ошибка: нельзя два раза объявить 'x'
}
```

Это не значит, что переменная с блочной областью видимости не может быть объявлена с переменной с областью видимости в той же функции.
Переменная с блочной областью просто должна быть объявлена в своем блоке

```ts
function f(condition, x) {
  if (condition) {
    let x = 100
    return x
  }

  return x
}

f(false, 0) // returns 0
f(true, 0) // returns 100
```

Способ введения нового имени во вложенной области называется _сокрытием_.
Это своего рода меч с двумя лезвиями, т.к. он может ввести некоторые баги, также как и избавить от других.
Например, представьте, как мы могли бы переписать функцию `sumMatrix`, используя переменные `let`.

```ts
function sumMatrix(matrix: number[][]) {
  let sum = 0
  for (let i = 0; i < matrix.length; i++) {
    var currentRow = matrix[i]
    for (let i = 0; i < currentRow.length; i++) {
      sum += currentRow[i]
    }
  }

  return sum
}
```

Эта версия цикла делает суммирование корректно, потому что `i` внутреннего цикла перекрывает `i` внешнего.

Такое сокрытие нужно обычно избегать, чтобы код был чище. Но в некоторых сценариях такой способ может идеально подходить для решения задачи.
Вы должны использовать лучшее решение на ваше усмотрение.

### Замыкание переменных с блочной областью видмости

Когда мы впервые коснулись замыкания переменных с объявлением `var`, мы коротко рассмотрели, как переменные ведут себя при замыкании.
Чтобы лучше понимать суть, представьте себе, что каждый раз, когда появляется новая область видимости, она создает свою "среду" для переменных.
Эта среда и ее захваченные извне переменные могут существовать даже после того, как все выражения внутри области видимости завершили свое выполнение.

```ts
function theCityThatAlwaysSleeps() {
  let getCity

  if (true) {
    let city = 'Seattle'
    getCity = function() {
      return city
    }
  }

  return getCity()
}
```

Из-за того, что мы захватили переменную `city` из ее среды, мы все еще можем получить к ней доступ, несмотря на тот факт, что блок `if` закончил выполнение.
Вспомните наш предыдущий пример с `setTimeout`. Мы закончили на необходимости использовать IIFE, чтобы захватить состояние переменной для каждой итерации цикла `for`.
В результате мы каждый раз создавали новую среду переменных для наших захваченных. Это доставляло немного боли, но, к счастью, нам не потребуется делать это снова в TypeScript.

Объявления `let` ведут себя совсем иначе, когда являются частью цикла.
Вместо того, чтобы вводить новую среду для цикла, они вводят новую область видимости для _каждой итерации_.
Так как это то, что мы делали с нашим IIFE, мы можем изменить наш старый пример `setTimeout`, используя объявления `let`.

```ts
for (let i = 0; i < 10; i++) {
  setTimeout(function() {
    console.log(i)
  }, 100 * i)
}
```

и как ожидалось, будет напечатано это

```text
0
1
2
3
4
5
6
7
8
9
```

## Объявления `const`

Объявления `const` - это еще один способ объявления переменных.

```ts
const numLivesForCat = 9
```

Они такие же как и `let`, только, согласно их названию, их значение не может быть изменено после того, как им однажды уже присвоили значение.
Другими словами, к ним применимы все правила области видимости `let`, но вы не можете их переназначить. Значение, с которым они связаны, является _неизменным_.

```ts
const numLivesForCat = 9
const kitty = {
  name: 'Aurora',
  numLives: numLivesForCat
}

// Ошибка
kitty = {
  name: 'Danielle',
  numLives: numLivesForCat
}

// Все хорошо
kitty.name = 'Rory'
kitty.name = 'Kitty'
kitty.name = 'Cat'
kitty.numLives--
```

Несмотря на то, что переменная была объявлена как `const`, ее внутренее состояние все еще может быть изменено.
К счастью, TypeScript позволяет вам определить свойства объекта доступными только на чтение: `readonly`.
[Раздел в Интерфейсах](./Interfaces.html) объясняет детали этого.

## `let` или `const`?

У нас есть два способа объявления с похожими правилами их области видимости, поэтому сам собой напрашивается вопрос о том, какой использовать.
Ответ будет таким же, как и на большинство широких вопросов: это зависит от обстоятельств.

Применяя [принцип наименьшего уровня привелегий](https://en.wikipedia.org/wiki/Principle_of_least_privilege), все объявления переменных, которые вы в дальнейшем не планируете менять, должны использовать `const`. Объясняется это тем, что если переменная не должна изменять свое значение, другие разработчики, которые работают над тем же кодом, не должны иметь возможность записи в объект. Это должно быть позволено только в случае реальной необходимости переназначения переменной.
Использование `const` делает код более предсказуемым и понятным при объяснении потока данных.

Большая часть этого руководства использует объявления `let`.

## Деструктурирование

Еще одно нововведение из стандарта ECMAScript 2015, которое есть в TypeScript, это деструктурирование (прим. переводчика "destructuring" - не "уничтожение").
За полной информацией об этом пройдите по ссылке [статья на Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).
В этом разделе мы приведем сокращенный вариант.

### Деструктурирование массивов

Самая простая форма деструктурирования - с использованием массива:

```ts
let input = [1, 2]
let [first, second] = input
console.log(first) // outputs 1
console.log(second) // outputs 2
```

Это создает две новых переменных с именами `first` и `second`.
В сущности это эквивалент обращения по индексу, просто более удобный:

```ts
first = input[0]
second = input[1]
```

Деструктурирование также работает с ранее объявленными переменными:

```ts
// swap variables
;[first, second] = [second, first]
```

И с параметрами функции:

```ts
function f([first, second]: [number, number]) {
  console.log(first)
  console.log(second)
}
f(input)
```

Вы можете создать переменную для оставшихся элементов списка, используя ситаксис `...name`:

```ts
let [first, ...rest] = [1, 2, 3, 4]
console.log(first) // outputs 1
console.log(rest) // outputs [ 2, 3, 4 ]
```

Конечно, т.к. это Javascript, вы можете просто проигнорировать их:

```ts
let [first] = [1, 2, 3, 4]
console.log(first) // outputs 1
```

Или какие-то определенные элементы:

```ts
let [, second, , fourth] = [1, 2, 3, 4]
```

### Деструктурирование объекта

Вы можете также деструктурировать объекты:

```ts
let o = {
  a: 'foo',
  b: 12,
  c: 'bar'
}
let { a, b } = o
```

Этот код создает новые переменные `a` и `b` из `o.a` и `o.b`.
Заметьте, что вы можете пропустить `c`, если она вам не нужна.

Как и в случае деструктурирования массива, вы можете назначить значения без объявления:

```ts
;({ a, b } = { a: 'baz', b: 101 })
```

Заметьте, что мы должны окружить это выражение с помощью круглых скобок.
JavaScript при парсинге рассматривает `{` как старт нового блока.

#### Переименование свойств

Вы можете также дать разные имена свойствам:

```ts
let { a: newName1, b: newName2 } = o
```

Этот синтакс может немного смущать. Вы читаете `a: newName1` как "`a` as `newName1`". Можно записать это по-другому, чтобы было понятнее:

```ts
let newName1 = o.a
let newName2 = o.b
```

Сбивает с толку то, что двоеточие здесь не обозначает тип.
Тип, если вы задаете его, все еще должен быть записан после деструктурирования:

```ts
let { a, b }: { a: string; b: number } = o
```

#### Значения по умолчанию

Значения по умолчанию позволяют определить свойство, даже если оно не задавалось:

```ts
function keepWholeObject(wholeObject: { a: string; b?: number }) {
  let { a, b = 1001 } = wholeObject
}
```

Функция `keepWholeObject` имеет переменную для `wholeObject`, как и свойства `a` and `b`, даже если `b` не определено.

### Объявление функций

Деструктурирование также работает с объявлением функций
Ниже приведен простой пример:

```ts
type C = { a: string; b?: number }
function f({ a, b }: C): void {
  // ...
}
```

Указание значений по умолчанию чаще употребляется для параметров, и использвание деструктурирования для этого может выглядеть запутанно.
Прежде всего, вы должны помнить о необходимости указать тип до значения по умолчанию.

```ts
function f({ a, b } = { a: '', b: 0 }): void {
  // ...
}
f() // ok, по умолчанию {a: "", b: 0}
```

Затем, вы должны не забыть дать значение по умолчанию для опциональных свойств деструктурированного параметра при определении функции.
Помните также, что `C` был определен с опциональным свойством `b`:

```ts
function f({ a, b = 0 } = { a: '' }): void {
  // ...
}
f({ a: 'yes' }) // ok, по умолчанию b = 0
f() // ok, по умолчанию {a: ""}, что также подразумевает b = 0
f({}) // ошибка, свойство 'a' в таком случае требуется задать
```

Используйте деструктурирование с осторожностью.
Как показал предыдущий пример, все сложные выражения деструктурирования имеют много ньюансов.
В особенности это касается многоуровневого вложенного деструктурирования, которое действительно сложно для понимания даже без переименования, значений по умолчанию и аннотаций типа.
Старайтесь оставлять выражения деструктурирования маленькими и простыми.

## Ссылки

- [Объявление переменных](http://typescript-lang.ru/docs/Variable%20Declarations.html)
