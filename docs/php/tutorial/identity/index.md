# Аутентификация пользователя на сайте. Сессии и куки

## Особенности работы протокола HTTP

Как вы узнали из прошлой главы, работа с веб-сайтами в интернете происходит по протоколу HTTP.
Это замечательный и простой протокол, который действует по схеме «запрос-ответ». То есть клиент (браузер) пользователя посылает на сервер запрос, состоящий, как правило, только из заголовков, а затем получает ответ в виде заголовков ответа и тела самого документа.

В отличие от многих других протоколов, HTTP не сохраняет своего состояния. Это означает отсутствие сохранения промежуточного состояния между парами «запрос-ответ».

Иными словами, сервер не «запоминает» клиентов; каждый запрос он обрабатывает с «чистого листа».

Для сервера нет никакой разницы: запросил один пользователь страницу десять раз или десять разных пользователей по разу. Для него все запросы одинаковые.

Чем это неудобно для нас?

Часто сайты должны уметь идентифицировать своих посетителей, чтобы сохранять и показывать им позже какую-либо информацию.

Например, интернет-магазины могут сохранять историю просмотров, чтобы рекомендовать потенциальным покупателям наиболее подходящие им товары. Или агрегатор новостей мог бы предложить пользователям выбирать только интересующие их рубрики.

К счастью, протокол HTTP, а также все браузеры предоставляют возможность сохранения информации о пользователе.

## Cookies

**Cookies** (в дальнейшем просто «куки») — небольшие фрагменты данных, которые веб-сервер отправляет браузеру.

Браузер сохраняет их у себя, а при следующем посещении веб-страницы отправляет обратно. Благодаря этому, веб-сервер сможет узнать своего «старого» посетитеиля, идентифицировать его.

С технической стороны, куки — это обычные HTTP заголовки.

Когда веб-сервер хочет записать куку в браузер пользователя, он отсылает специальный заголовок ответа с названием Set-Cookie. В этом заголовке должна содержаться необходимая информация и дополнительные аттрибуты, о которых пойдёт речь далее.

В следующий раз, когда браузер пользователя запросит веб-страницу с того же сайта, в числе прочих заголовков он передаст заголовок запроса Cookie. Веб-сервер получит эту информацию, и она будет доступна также и для PHP.

### Пример

Задача очень проста: сохранять и показывать посетителю страницы, сколько раз он посетил наш сайт. Для этого будем сохранять количество посещений в отдельной куке, увеличивая значения на единицу при каждой загрузке страницы.

### Как установить куки: функция setcookie

Являясь серверным языком программирования, PHP может управлять заголовками, которые отправляет сервер, а значит может устанавливать и читать куки.

Чтобы добавить новую куку, необходимо вначале определиться со следующими критериями:

- Название этой куки (может состоять только из символов латинского алфавита и цифр);
- Значение, которое предполагается хранить;
- Срок жизни куки — это обязательное условие.

За установку куки в PHP отвечает функция `setcookie`, ей нужно передать как минимум три параметра, описанных выше. Пример:

```php
<?php
setcookie("visit_count", 1, strtotime("+30 days"));
```

Обратите внимание, что срок жизни указывается в относительной величине. В этом примере кука будет существовать ровно 30 дней с момента установки.

### Как прочитать куки

В PHP максимально упрощён процесс чтения информации из кукисов. Все переданные сервером куки становятся автоматически доступны в специальном глобальном массиве `$_COOKIE`.

Так, чтобы получить содержимое куки с именем `visit_count`, достаточно обратиться к одноимённому элементу массива `$_COOKIE`, например вот так:

```php
<?php
print($_COOKIE["visit_count"]);
```

Обратите внимание: установив в сценарии куку через `setcookie`, прочитать её можно будет только при следующем посещении страницы.

### Собираем всё вместе

Теперь, научившись устанавливать и читать куки, напишем полноценный сценарий, который будет считать и выводить количество посещений страницы пользователем:

```php
<?php
$visit_count = 1;

if (isset($_COOKIE["visit_count"])) {
    $visit_count = $_COOKIE["visit_count"] + 1;
}

setcookie("visit_count", $visit_count, strtotime("+30 days"));

print("Количество посещений: " . $visit_count);
```

## Сессии

Мы уже умеем сохранять информацию для пользователя между посещениями страницы с помощью кук. Но зачем же нам ещё сессии, и для чего они нужны?

Сессии, они же сеансы, это, по сути, просто удобная обёртка над куками. Они также позволяют хранить данные, релевантные пользователю, но с некоторыми отличиями и ограничениями:

- Данные хранятся не произвольное время, а только до закрытия вкладки с веб-страницей.
- Чтобы сессии работали, в начале каждого сценария надо вызывать функцию `session_start()`.
- Доступный объём для хранения информации намного больше.

Запись и чтение информации при использовании сессий выглядит просто как работа со специальным массивом `$_SESSION`.

### Как устроены сессии

1. PHP генерирует уникальный идентификатор браузера.
2. Идентификатор сохраняется в специальную куку и передаётся с каждым запросом.
3. Все данные, которые записываются в сессию, PHP автоматически сохраняет в специальном файле на сервере.

Благодаря существованию сессий в PHP, мы можем сохранять любые данные так же просто, как присваивать их переменным. Но, в отличие от переменных, эти данные будут сохраняться для пользователя между запросами в пределах сеанса.

Перепишем сценарий для подсчета посещений, но теперь используем сессии:

```php
<?php
session_start();
$visit_count = 1;

if (isset($_SESSION["visit_count"])) {
    $visit_count = $_SESSION["visit_count"] + 1;
}

$_SESSION["visit_count"] = $visit_count;

print("Количество посещений: " . $visit_count);
```

## Аутентификация

Представим интернет-магазин. Все его страницы можно разделить на две половины: публичные и приватные.

К публичным относятся страницы каталога, информации о товаре, условия доставки и так далее. К приватным — корзина покупок, история заказов.

Совершенно очевидно, что корзина покупок у каждого покупателя должна быть своя, а иметь к ней доступ должен только сам владелец и никто больше.

Процедура проверки возможности доступа пользователя к определенной части сайта и называется аутентификацией.

Весь процесс аутентификации всегда состоит из нескольких шагов:

1. При попытке доступа к закрытой части сайта, пользователь видит форму, где он должен ввести свой логин и пароль.
2. Форма отправляется, а полученные данные сравниваются с действительным логином и паролем существующего пользователя.
3. Если данные совпадают, то пользователь считается аутентифицированным и получает доступ к приватной части сайта.
4. При повторном открытии этой страницы пользователь не должен повторно вводить пароль, если он уже делал это в рамках текущего сеанса.

### Ещё немного терминологии

Следует различать два термина: аутентификация и авторизация.

_Аутентификация_ — проверка подлинности предоставленного пользователем идентификатора (пара логин-пароль).

_Авторизация_ — процесс проверки и предоставления прав пользователю на выполнение определённого действия.

В примере с интернет-магазином аутентификация выполняется, когда пользователь заполняет форму входа и попадает в свой личный кабинет. Сценарий, обрабатывающий форму, лишь проверяет, что такой пользователь существует, и его пароль совпадает.

Авторизация включается в работу, когда пользователь выполняет какое-нибудь действие. Например, удаляет товар из своей корзины. Во время этого действия сценарий должен проверить принадлежность товара к корзине этого пользователя. Без такой проверки пользователь мог бы удалить товар из чужой корзины.

Логика авторизации намного сложнее, чем простая проверка совпадения почты и пароля при входе на сайт. В авторизацию могут также входить следующие понятия: группы пользователей, виды действий, ресурсы, иерархия ролей и действий. Этой теме можно посвятить отдельную главу. Мы не рассматриваем авторизацию в рамках этого учебника, потому что эта тема выходит за рамки «базовой».

## Регистрация на сайте

Перед тем, как мы начнем добавлять аутентификацию на своем сайте, придётся добавить форму для регистрации нового аккаунта.

_Аккаунт_ — это учётная запись пользователя.

Чтобы завести аккаунт, требуется пройти регистрацию — это заполнение специальной формы, где пользователь указывает свою почту, пароль, и, возможно, дополнительную информацию.

После регистрации все данные из формы сохраняются в базе данных как есть. Но хранению паролей нужно уделить особое внимание.

### Хранение паролей

Пароль пользователя — это секретный набор символов, который используется в дальнейшем в ходе аутентификации. Зная пароль пользователя, злоумышленник может войти на сайт под его именем. По этой причине пароль нельзя хранить в базе в открытом виде. Ведь если информацию из БД сайта украдут, то данные всех пользователей станут скомпрометированными.

Вместо самого пароля, в базе будут храниться их отпечатки — хэши.

### Что такое хеширование

_Отпечаток (хэш)_ — это результат работы функции хэширования, которая вернёт для любого значения строку фиксированной длины.

Используя специальный математический алгоритм, такая функция умеет преобразовывать любую переданную информацию к строке фиксированной длины (например, 32 или 64 символа). Причём любому массиву информации, будь это все статьи из Википедии, или одно слово, всегда будет соответствовать уникальный отпечаток. Повторный вызов функции для одного и того же исходника всегда возвращает один и тот же хэш.

Обратная операция (получить из отпечатка оригинал) невозможна.

Возьмём простой пример. У нас есть информация, для которой мы хотим получить отпечаток. Пусть такой информацией будет следующая строка:

```
«Я знаю только то, что ничего не знаю, но другие не знают и этого»
```

Результат обработки этой строки хэширующей функцией SHA-1 будет таким:

```
6b3cb0df50fe814dee886b4e1c747dda6ce88b37
```

Хэширующие функции часто используются для контроля целостности информации при передачи по сети. Например, чтобы убедиться в том, что загруженный файл не был повреждён, достаточно получить его хэш и сравнить данный хэш с опубликованным на сайте. Если в файле поменялся хоть один байт, то эти отпечатки будут совершенно разными.

Нам же функции хэширования помогут для сравнения паролей.

### Реализация регистрации пользователя

Вернёмся к форме регистрации.

Выше говорилось, что вместо пароля лучше хранить его отпечаток. Для получения отпечатка существуют множество хэшируюших функций. К счастью, нам не надо разбираться в их многообразии, потому что в PHP есть стандартная функция, которая делает ровно то, что нужно.

Вот пример как из пароля получить отпечаток, пригодный для хранения в базе:

```php
<?php
$passwordHash = password_hash('iloveponies', PASSWORD_DEFAULT);
```

Вызов этой функции вернёт следующую строку:

```
$2y$10$a1pgDBerBsqD24D7qOAsl.QFTvwxQQGe4r1oWhD7f9yEnDvx4i7tW
```

Именно это значение и следует хранить в БД, вместо пароля.

### Проверка пароля при входе на сайт

После регистрации у пользователя появляется свой аккаунт на сайте, и он может его использовать. Это значит, что теперь потребуется сделать форму входа. Форма будет проверять правильность введённого логина и пароля, чтобы дать пользователю доступ к закрытым частям сайта.

Вначале мы ищем в таблице с пользователями запись с E-mail, равным полученному из формы. Если такая запись существует, то следующий шаг — это проверить корректность пароля.

Для сравнения пароля с его хэшом существует функция `password_verify`. Ей передаётся пароль и хэш, с которым надо сравнить данный пароль. Функция вернет `true` или `false` в зависимости от результата сравнения:

```php
<?php
$res = password_verify('bad-password', $passwordHash);
```

## Использование сессии для контроля доступа

Сессии чаще всего используются для хранения информации о залогиненном пользователе. Принцип работы здесь очень простой: внутри сценария, ответственного за обработку формы входа, открывается новая сессия, куда записывается информация о вошедшем пользователе. Такой информацией может быть ассоциативный массив со всеми значениями из соответствующей записи из БД.

Затем добавим код, проверяющий существование сессии в сценарии, которые должны быть закрыты от анонимных пользователей. Если сессия пуста, значит данный пользователь не выполнял вход на сайт, и доступа к данной странице он не имеет.

В этом случае можно вернуть код ответа 403 и показать сообщение об ошибке, либо принудительно выполнить переадресацию на главную страницу.

### Выход с сайта

Если на сайте есть вход, то должен быть и выход. Таким выходом будет специальный сценарий, который очистит сессию и переадресует на главную страницу.

Чтобы очистить сессию, достаточно очистить массив `$_SESSION`:

```php
<?php
$_SESSION = [];
```
